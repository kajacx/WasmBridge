use std::str::FromStr;

use conversions::derive_lift_struct;
use proc_macro2::TokenStream;
use quote::quote;
use regex::Regex;
use syn::Attribute;

mod conversions;
mod from_js_value;
mod original;
mod to_js_value;

// #[proc_macro_derive(Lift, attributes(component))]
// pub fn lift_sys(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
//     replace_namespace(original::lift(input))
// }

// #[proc_macro_derive(Lower, attributes(component))]
// pub fn lower_sys(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
//     replace_namespace(original::lower(input))
// }

#[proc_macro_derive(ComponentType, attributes(component))]
pub fn component_type(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    replace_namespace(original::component_type(input)).into()
}

#[proc_macro]
pub fn flags(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    replace_namespace(original::flags(input)).into()
}

#[proc_macro]
pub fn bindgen_sys(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    replace_namespace(original::bindgen(input)).into()
}

#[proc_macro]
pub fn bindgen_js(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let as_string = replace_namespace(original::bindgen(input)).to_string();

    // Clone exported function
    let regex = Regex::new("\\*\\s*__exports\\.typed_func([^?]*)\\?\\.func\\(\\)").unwrap();
    let as_string = regex.replace_all(&as_string, "__exports.typed_func$1?.func().clone()");

    // Clone "inner" function
    let regex = Regex::new("new_unchecked\\(self\\.([^)]*)\\)").unwrap();
    let as_string = regex.replace_all(&as_string, "new_unchecked(self.$1.clone())");

    // Workaround to get data reference
    let regex = Regex::new("let host = get\\(caller\\.data_mut\\(\\)\\)\\s*;").unwrap();
    let as_string = regex.replace_all(&as_string, "let host = get(&mut caller);\n");

    // TODO: these static bounds are not great
    let regex = Regex::new("add_to_linker\\s*<\\s*T").unwrap();
    let as_string = regex.replace_all(&as_string, "add_to_linker<T: 'static");

    let regex = Regex::new("add_root_to_linker\\s*<\\s*T").unwrap();
    let as_string = regex.replace_all(&as_string, "add_root_to_linker<T: 'static");

    // Remove the "ComponentType" trait, it's about memory and type safety, we don't need to care about it as much
    let regex = Regex::new("#\\[derive[^C]*ComponentType\\s*\\)\\s*\\]").unwrap();
    let as_string = regex.replace_all(&as_string, "");

    let regex = Regex::new("const _ : \\(\\) =[^}]*ComponentType[^}]*\\}\\s*;").unwrap();
    let as_string = regex.replace_all(&as_string, "");

    // Replace the "Lift" trait with "FromJsValue"
    // let regex = Regex::new("#\\[derive\\([^)]*Lift\\)\\]").unwrap();
    // let as_string = regex.replace_all(&as_string, "#[derive(wasm_bridge::component::FromJsValue)]");

    // Replace the "Lower" trait with "ToJsValue"
    // let regex = Regex::new("#\\[derive\\([^)]*Lower\\)\\]").unwrap();
    // let as_string = regex.replace_all(&as_string, "#[derive(wasm_bridge::component::ToJsValue)]");

    // Remove asynchrony
    let as_string = if cfg!(feature = "async") {
        let regex = Regex::new("Box[^:]*::[^n]*new[^(]*\\([^a]*async[^m]*move").unwrap();
        let as_string = regex.replace_all(&as_string, "(");

        // TODO: this removes "await"s even in places where it isn't supposed to
        as_string.replace(".await", "")
    } else {
        as_string.to_string()
    };

    // eprintln!("#[cfg(test)]");
    // eprintln!("#[allow(warnings)]");
    // eprintln!("mod test {{");
    // eprintln!("  pub mod wasm_bridge {{");
    // eprintln!("    pub use crate::*;");
    // eprintln!("  }}");
    // eprintln!("  {as_string}");
    // eprintln!("}}");

    proc_macro::TokenStream::from_str(&as_string).unwrap()
}

#[proc_macro_derive(Lift, attributes(component))]
pub fn lift(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let input: syn::DeriveInput = syn::parse(input).unwrap();
    let sys = replace_namespace(original::lower(&input));
    return quote! {}.into();

    let name = input.ident;
    let enum_type = EnumType::from_attributes(&input.attrs);

    let js = match input.data {
        syn::Data::Struct(data) => derive_lift_struct(&name, data),
        syn::Data::Enum(_data) => match enum_type.expect("enum should be enum or variant") {
            EnumType::Enum => todo!("lift enum"),
            EnumType::Variant => todo!("lift variant"),
        },
        syn::Data::Union(_) => unimplemented!("Union type should not be generated by wit bindgen"),
    };

    quote! {
        #[cfg(target_arch = "wasm32")]
        {
            #js
        }
        #[cfg(not(target_arch = "wasm32"))]
        {
            #sys
        }
    }
    .into()
}

#[proc_macro_derive(Lower, attributes(component))]
pub fn lower(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let input: syn::DeriveInput = syn::parse(input.clone()).unwrap();
    let sys = replace_namespace(original::lift(&input));

    let name = input.ident;
    let enum_type = EnumType::from_attributes(&input.attrs);

    let js = match input.data {
        syn::Data::Struct(data) => conversions::derive_lower_struct(&name, data),
        syn::Data::Enum(_data) => match enum_type.expect("enum should be enum or variant") {
            EnumType::Enum => todo!("lower enum"),
            EnumType::Variant => todo!("lower variant"),
        },
        syn::Data::Union(_) => unimplemented!("Union type should not be generated by wit bindgen"),
    };
    eprintln!("{}", js);

    quote! {
        #[cfg(target_arch = "wasm32")]
        const _: () = {
            #js
        };

        #[cfg(not(target_arch = "wasm32"))]
        const _: () = {
            #sys
        };
    }
    .into()
}

#[proc_macro_attribute]
pub fn async_trait(
    _attr: proc_macro::TokenStream,
    input: proc_macro::TokenStream,
) -> proc_macro::TokenStream {
    let as_string = input.to_string();

    // TODO: this is a really hacky way to do it
    let regex = Regex::new("async\\s*fn").unwrap();
    let as_string = regex.replace_all(&as_string, "fn");

    proc_macro::TokenStream::from_str(&as_string).unwrap()
}

fn replace_namespace(stream: proc_macro::TokenStream) -> TokenStream {
    let as_string = stream.to_string();

    // Replace wasmtime:: package path with wasm_bridge::
    let regex = Regex::new("wasmtime[^:]*::").unwrap();
    let as_string = regex.replace_all(&as_string, "wasm_bridge::");

    TokenStream::from_str(&as_string).unwrap()
}

enum EnumType {
    Enum,
    Variant,
}

impl EnumType {
    fn from_attributes(attributes: &[Attribute]) -> Option<Self> {
        attributes.iter().find_map(|attr| {
            // TODO: How to match the attribute properly?
            let value = attr.tokens.to_string();
            if value == "(enum)" {
                Some(EnumType::Enum)
            } else if value == "(variant)" {
                Some(EnumType::Variant)
            } else {
                None
            }
        })
    }
}
